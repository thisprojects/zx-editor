import { Attribute, DrawBounds, TileSize } from '@/types';
import { CHAR_SIZE, MAX_UDG_CHARS, SCREEN_CHARS_WIDTH, SCREEN_CHARS_HEIGHT, TILE_SIZES } from '@/constants';

interface ExportParams {
  pixels: boolean[][];
  attributes: Attribute[][];
  bounds: DrawBounds;
  fileName: string;
}

// Export as ASM file (compact, game-ready format)
export function exportASM({ pixels, attributes, bounds, fileName }: ExportParams): boolean {
  const { minCharX, minCharY, width: exportWidth, height: exportHeight } = bounds;
  const totalChars = exportWidth * exportHeight;

  if (totalChars > MAX_UDG_CHARS) {
    alert(`Drawn content spans ${totalChars} characters, but ZX Spectrum only has ${MAX_UDG_CHARS} UDG slots. Please reduce the drawn area.`);
    return false;
  }

  const lines: string[] = [];

  // Header
  lines.push('; ZX Spectrum UDG Sprite Data');
  lines.push('; Generated by ZX Spectrum UDG Editor');
  lines.push(';');
  lines.push(`; Sprite dimensions: ${exportWidth}x${exportHeight} characters (${exportWidth * 8}x${exportHeight * 8} pixels)`);
  lines.push(`; Total characters: ${totalChars}`);
  lines.push(`; UDG data size: ${totalChars * 8} bytes`);
  lines.push(`; Attribute data size: ${totalChars} bytes`);
  lines.push('');

  // Constants
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Constants');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(`SPRITE_WIDTH    equ ${exportWidth}          ; Width in characters`);
  lines.push(`SPRITE_HEIGHT   equ ${exportHeight}          ; Height in characters`);
  lines.push(`SPRITE_CHARS    equ ${totalChars}         ; Total characters`);
  lines.push(`UDG_BYTES       equ ${totalChars * 8}        ; Bytes of UDG pixel data`);
  lines.push(`FIRST_UDG_CHAR  equ 144         ; First UDG character code`);
  lines.push('');

  // UDG pixel data - compact format (8 bytes per line = 1 character)
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; UDG Pixel Data (8 bytes per character, MSB=leftmost pixel)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('sprite_udg_data:');

  let charIndex = 0;
  for (let charY = minCharY; charY < minCharY + exportHeight; charY++) {
    for (let charX = minCharX; charX < minCharX + exportWidth; charX++) {
      const bytes: string[] = [];
      for (let row = 0; row < CHAR_SIZE; row++) {
        let byte = 0;
        for (let col = 0; col < CHAR_SIZE; col++) {
          const pixelX = charX * CHAR_SIZE + col;
          const pixelY = charY * CHAR_SIZE + row;
          if (pixels[pixelY][pixelX]) {
            byte |= 1 << (7 - col);
          }
        }
        bytes.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
      }
      lines.push(`        defb ${bytes.join(',')}  ; char ${charIndex} (row ${charY - minCharY}, col ${charX - minCharX})`);
      charIndex++;
    }
  }

  lines.push('');

  // Attribute data
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Attribute Data (1 byte per character)');
  lines.push('; Format: 0BPPPIII where B=bright, P=paper(0-7), I=ink(0-7)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('sprite_attr_data:');

  for (let charY = minCharY; charY < minCharY + exportHeight; charY++) {
    const rowAttrs: string[] = [];
    for (let charX = minCharX; charX < minCharX + exportWidth; charX++) {
      const attr = attributes[charY][charX];
      const byte = (attr.bright ? 0x40 : 0) | (attr.paper << 3) | attr.ink;
      rowAttrs.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
    }
    lines.push(`        defb ${rowAttrs.join(',')}  ; row ${charY - minCharY}`);
  }

  lines.push('');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Usage Example');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(';');
  lines.push('; To use this sprite in your game:');
  lines.push(';');
  lines.push('; 1. Include this file in your project');
  lines.push(';');
  lines.push('; 2. Set up UDGs at startup:');
  lines.push(';        ld hl,sprite_udg_data');
  lines.push(';        ld (23675),hl           ; Set UDG system variable');
  lines.push(';');
  lines.push('; 3. Print sprite at screen position (row,col):');
  lines.push(';        call print_sprite');
  lines.push(';');
  lines.push('; Or copy UDG data to a custom location:');
  lines.push(';        ld hl,sprite_udg_data');
  lines.push(';        ld de,your_udg_buffer');
  lines.push(';        ld bc,UDG_BYTES');
  lines.push(';        ldir');
  lines.push('');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Helper Routines (optional - remove if not needed)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('');
  lines.push('; Print sprite at position (B=row, C=col)');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('print_sprite:');
  lines.push('        ld d,SPRITE_HEIGHT');
  lines.push('        ld e,FIRST_UDG_CHAR');
  lines.push('_ps_row_loop:');
  lines.push('        push bc');
  lines.push('        push de');
  lines.push('        ; Position cursor (AT row,col)');
  lines.push('        ld a,22');
  lines.push('        rst 16');
  lines.push('        ld a,b');
  lines.push('        rst 16');
  lines.push('        ld a,c');
  lines.push('        rst 16');
  lines.push('        ; Print row of UDGs');
  lines.push('        ld b,SPRITE_WIDTH');
  lines.push('_ps_col_loop:');
  lines.push('        ld a,e');
  lines.push('        rst 16');
  lines.push('        inc e');
  lines.push('        djnz _ps_col_loop');
  lines.push('        pop de');
  lines.push('        pop bc');
  lines.push('        ; Move to next row');
  lines.push('        ld a,e');
  lines.push('        add a,SPRITE_WIDTH');
  lines.push('        ld e,a');
  lines.push('        inc b');
  lines.push('        dec d');
  lines.push('        jr nz,_ps_row_loop');
  lines.push('        ret');
  lines.push('');
  lines.push('; Set attributes for sprite at position (B=row, C=col)');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('set_sprite_attrs:');
  lines.push('        ld hl,sprite_attr_data');
  lines.push('        ld d,SPRITE_HEIGHT');
  lines.push('_sa_row_loop:');
  lines.push('        push bc');
  lines.push('        push de');
  lines.push('        ; Calculate attribute address: 22528 + row*32 + col');
  lines.push('        ld a,b');
  lines.push('        rrca');
  lines.push('        rrca');
  lines.push('        rrca');
  lines.push('        ld e,a');
  lines.push('        and $E0');
  lines.push('        ld d,a');
  lines.push('        ld a,e');
  lines.push('        and $03');
  lines.push('        or $58                  ; High byte of attr area');
  lines.push('        ld d,a');
  lines.push('        ld a,b');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        and $E0');
  lines.push('        or c');
  lines.push('        ld e,a');
  lines.push('        ; Copy attribute row');
  lines.push('        ld b,SPRITE_WIDTH');
  lines.push('_sa_col_loop:');
  lines.push('        ld a,(hl)');
  lines.push('        ld (de),a');
  lines.push('        inc hl');
  lines.push('        inc e');
  lines.push('        djnz _sa_col_loop');
  lines.push('        pop de');
  lines.push('        pop bc');
  lines.push('        inc b');
  lines.push('        dec d');
  lines.push('        jr nz,_sa_row_loop');
  lines.push('        ret');
  lines.push('');

  const content = lines.join('\n');
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${fileName}.asm`;
  a.click();
  URL.revokeObjectURL(url);

  return true;
}

// Screen export parameters
interface ScreenExportParams {
  pixels: boolean[][];
  attributes: Attribute[][];
  fileName: string;
}

// Export full ZX Spectrum screen as ASM file
// Screen memory layout: 6144 bytes display + 768 bytes attributes = 6912 bytes
// Display file at $4000, attributes at $5800
export function exportScreenASM({ pixels, attributes, fileName }: ScreenExportParams): boolean {
  const lines: string[] = [];

  // Header
  lines.push('; ZX Spectrum Full Screen Data');
  lines.push('; Generated by ZX Spectrum Scene Editor');
  lines.push(';');
  lines.push('; Screen dimensions: 256x192 pixels (32x24 characters)');
  lines.push('; Display data: 6144 bytes');
  lines.push('; Attribute data: 768 bytes');
  lines.push('; Total size: 6912 bytes');
  lines.push(';');
  lines.push('; Memory layout:');
  lines.push(';   Display file: $4000-$57FF (16384-22527)');
  lines.push(';   Attributes:   $5800-$5AFF (22528-23295)');
  lines.push('');

  // Constants
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Constants');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('SCREEN_START    equ $4000       ; Display file start');
  lines.push('ATTR_START      equ $5800       ; Attribute file start');
  lines.push('DISPLAY_SIZE    equ 6144        ; Display file size in bytes');
  lines.push('ATTR_SIZE       equ 768         ; Attribute file size in bytes');
  lines.push('SCREEN_SIZE     equ 6912        ; Total screen size in bytes');
  lines.push('');

  // Generate display file data in ZX Spectrum native format
  // The display file has a peculiar memory layout:
  // - 3 "thirds" of the screen (0-63, 64-127, 128-191 pixel rows)
  // - Each third: pixel lines are interleaved by character row
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Display File Data (6144 bytes)');
  lines.push('; Native ZX Spectrum screen format - can be copied directly to $4000');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('screen_display_data:');

  // Process each third of the screen
  for (let third = 0; third < 3; third++) {
    lines.push(`; --- Third ${third + 1} (pixel rows ${third * 64}-${third * 64 + 63}) ---`);

    // Each third has 8 pixel lines per character row, interleaved
    for (let pixelLine = 0; pixelLine < 8; pixelLine++) {
      for (let charRow = 0; charRow < 8; charRow++) {
        const screenRow = third * 64 + charRow * 8 + pixelLine;
        const rowBytes: string[] = [];

        for (let col = 0; col < SCREEN_CHARS_WIDTH; col++) {
          let byte = 0;
          for (let bit = 0; bit < 8; bit++) {
            const pixelX = col * 8 + bit;
            if (pixels[screenRow]?.[pixelX]) {
              byte |= 1 << (7 - bit);
            }
          }
          rowBytes.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        }

        // Split into two lines of 16 bytes each for readability
        lines.push(`        defb ${rowBytes.slice(0, 16).join(',')}`);
        lines.push(`        defb ${rowBytes.slice(16).join(',')}`);
      }
    }
  }

  lines.push('');

  // Generate attribute data (linear, one byte per character cell)
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Attribute Data (768 bytes)');
  lines.push('; Linear format - can be copied directly to $5800');
  lines.push('; Format: 0BPPPIII where B=bright, P=paper(0-7), I=ink(0-7)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('screen_attr_data:');

  for (let row = 0; row < SCREEN_CHARS_HEIGHT; row++) {
    const rowAttrs: string[] = [];
    for (let col = 0; col < SCREEN_CHARS_WIDTH; col++) {
      const attr = attributes[row]?.[col] || { ink: 7, paper: 0, bright: false };
      const byte = (attr.bright ? 0x40 : 0) | (attr.paper << 3) | attr.ink;
      rowAttrs.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
    }
    // Split into two lines of 16 bytes each for readability
    lines.push(`        defb ${rowAttrs.slice(0, 16).join(',')}  ; row ${row}`);
    lines.push(`        defb ${rowAttrs.slice(16).join(',')}`);
  }

  lines.push('');

  // Helper routines
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Helper Routines');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('');
  lines.push('; Load screen - copies display and attribute data to screen memory');
  lines.push('; Call this routine to display the screen');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('load_screen:');
  lines.push('        ; Copy display data to screen');
  lines.push('        ld hl,screen_display_data');
  lines.push('        ld de,SCREEN_START');
  lines.push('        ld bc,DISPLAY_SIZE');
  lines.push('        ldir');
  lines.push('        ; Copy attribute data');
  lines.push('        ld hl,screen_attr_data');
  lines.push('        ld de,ATTR_START');
  lines.push('        ld bc,ATTR_SIZE');
  lines.push('        ldir');
  lines.push('        ret');
  lines.push('');
  lines.push('; Clear screen to black');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('clear_screen:');
  lines.push('        ; Clear display file');
  lines.push('        ld hl,SCREEN_START');
  lines.push('        ld de,SCREEN_START+1');
  lines.push('        ld bc,DISPLAY_SIZE-1');
  lines.push('        ld (hl),0');
  lines.push('        ldir');
  lines.push('        ; Clear attributes (black on black)');
  lines.push('        ld hl,ATTR_START');
  lines.push('        ld de,ATTR_START+1');
  lines.push('        ld bc,ATTR_SIZE-1');
  lines.push('        ld (hl),0');
  lines.push('        ldir');
  lines.push('        ret');
  lines.push('');
  lines.push('; Set border colour (A = colour 0-7)');
  lines.push('; Modifies: AF');
  lines.push('set_border:');
  lines.push('        out ($FE),a');
  lines.push('        ret');
  lines.push('');

  // Usage example
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Usage Example');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(';');
  lines.push('; To display this screen in your program:');
  lines.push(';');
  lines.push(';   include "' + fileName + '.asm"');
  lines.push(';');
  lines.push(';   ; Display the loading screen');
  lines.push(';   call load_screen');
  lines.push(';');
  lines.push(';   ; Optionally set border colour');
  lines.push(';   ld a,0              ; Black border');
  lines.push(';   call set_border');
  lines.push(';');
  lines.push(';   ; Wait for keypress');
  lines.push(';   call wait_key');
  lines.push(';');
  lines.push('; For loading screens, you may want to load this data during tape loading');
  lines.push('; by placing it at the start of your program.');
  lines.push('');

  const content = lines.join('\n');
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${fileName}_screen.asm`;
  a.click();
  URL.revokeObjectURL(url);

  return true;
}

// Tile export parameters
interface TileExportParams {
  tileSize: TileSize;
  pixels: boolean[][];
  attributes: Attribute[][];
  fileName: string;
}

// Export tile as ASM file
export function exportTileASM({ tileSize, pixels, attributes, fileName }: TileExportParams): boolean {
  const config = TILE_SIZES[tileSize];
  const { chars: charDim, totalChars, label } = config;
  const lines: string[] = [];

  // Header
  lines.push('; ZX Spectrum Tile Data');
  lines.push('; Generated by ZX Spectrum Tile Editor');
  lines.push(';');
  lines.push(`; Tile dimensions: ${label} pixels (${charDim}x${charDim} characters)`);
  lines.push(`; Total characters: ${totalChars}`);
  lines.push(`; Pixel data size: ${totalChars * 8} bytes`);
  lines.push(`; Attribute data size: ${totalChars} bytes`);
  lines.push('');

  // Constants
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Constants');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(`TILE_WIDTH      equ ${charDim}           ; Width in characters`);
  lines.push(`TILE_HEIGHT     equ ${charDim}           ; Height in characters`);
  lines.push(`TILE_CHARS      equ ${totalChars}           ; Total characters`);
  lines.push(`TILE_BYTES      equ ${totalChars * 8}          ; Bytes of pixel data`);
  lines.push(`FIRST_UDG_CHAR  equ 144         ; First UDG character code`);
  lines.push('');

  // Pixel data - compact format (8 bytes per line = 1 character)
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Tile Pixel Data (8 bytes per character, MSB=leftmost pixel)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('tile_data:');

  let charIndex = 0;
  for (let charY = 0; charY < charDim; charY++) {
    for (let charX = 0; charX < charDim; charX++) {
      const bytes: string[] = [];
      for (let row = 0; row < CHAR_SIZE; row++) {
        let byte = 0;
        for (let col = 0; col < CHAR_SIZE; col++) {
          const pixelX = charX * CHAR_SIZE + col;
          const pixelY = charY * CHAR_SIZE + row;
          if (pixels[pixelY]?.[pixelX]) {
            byte |= 1 << (7 - col);
          }
        }
        bytes.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
      }
      if (totalChars > 1) {
        lines.push(`        defb ${bytes.join(',')}  ; char ${charIndex} (row ${charY}, col ${charX})`);
      } else {
        lines.push(`        defb ${bytes.join(',')}`);
      }
      charIndex++;
    }
  }

  lines.push('');

  // Attribute data
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Tile Attribute Data (1 byte per character)');
  lines.push('; Format: 0BPPPIII where B=bright, P=paper(0-7), I=ink(0-7)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('tile_attr_data:');

  for (let charY = 0; charY < charDim; charY++) {
    const rowAttrs: string[] = [];
    for (let charX = 0; charX < charDim; charX++) {
      const attr = attributes[charY]?.[charX] || { ink: 7, paper: 0, bright: true };
      const byte = (attr.bright ? 0x40 : 0) | (attr.paper << 3) | attr.ink;
      rowAttrs.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
    }
    if (charDim > 1) {
      lines.push(`        defb ${rowAttrs.join(',')}  ; row ${charY}`);
    } else {
      lines.push(`        defb ${rowAttrs.join(',')}`);
    }
  }

  lines.push('');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Usage Example');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(';');
  lines.push('; To use this tile in your game:');
  lines.push(';');
  lines.push(`;   include "${fileName}_tile.asm"`);
  lines.push(';');
  lines.push('; 1. Set up UDGs at startup:');
  lines.push(';        ld hl,tile_data');
  lines.push(';        ld (23675),hl           ; Set UDG system variable');
  lines.push(';');
  lines.push('; 2. Print tile at screen position (B=row, C=col):');
  lines.push(';        ld b,10                 ; Row');
  lines.push(';        ld c,15                 ; Column');
  lines.push(';        call print_tile');
  lines.push(';        call set_tile_attrs');
  lines.push('');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Helper Routines');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('');
  lines.push('; Print tile at position (B=row, C=col)');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('print_tile:');
  lines.push('        push bc');
  lines.push('        ; Set UDG pointer');
  lines.push('        ld hl,tile_data');
  lines.push('        ld (23675),hl');
  lines.push('        pop bc');
  lines.push('        ld d,TILE_HEIGHT');
  lines.push('        ld e,FIRST_UDG_CHAR');
  lines.push('_pt_row_loop:');
  lines.push('        push bc');
  lines.push('        push de');
  lines.push('        ; Position cursor (AT row,col)');
  lines.push('        ld a,22');
  lines.push('        rst 16');
  lines.push('        ld a,b');
  lines.push('        rst 16');
  lines.push('        ld a,c');
  lines.push('        rst 16');
  lines.push('        ; Print row of tile characters');
  lines.push('        ld b,TILE_WIDTH');
  lines.push('_pt_col_loop:');
  lines.push('        ld a,e');
  lines.push('        rst 16');
  lines.push('        inc e');
  lines.push('        djnz _pt_col_loop');
  lines.push('        pop de');
  lines.push('        pop bc');
  lines.push('        ; Move to next row');
  lines.push('        ld a,e');
  lines.push('        add a,TILE_WIDTH');
  lines.push('        ld e,a');
  lines.push('        inc b');
  lines.push('        dec d');
  lines.push('        jr nz,_pt_row_loop');
  lines.push('        ret');
  lines.push('');
  lines.push('; Set attributes for tile at position (B=row, C=col)');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('set_tile_attrs:');
  lines.push('        ld hl,tile_attr_data');
  lines.push('        ld d,TILE_HEIGHT');
  lines.push('_sta_row_loop:');
  lines.push('        push bc');
  lines.push('        push de');
  lines.push('        ; Calculate attribute address: 22528 + row*32 + col');
  lines.push('        ld a,b');
  lines.push('        rrca');
  lines.push('        rrca');
  lines.push('        rrca');
  lines.push('        ld e,a');
  lines.push('        and $E0');
  lines.push('        ld d,a');
  lines.push('        ld a,e');
  lines.push('        and $03');
  lines.push('        or $58                  ; High byte of attr area');
  lines.push('        ld d,a');
  lines.push('        ld a,b');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        and $E0');
  lines.push('        or c');
  lines.push('        ld e,a');
  lines.push('        ; Copy attribute row');
  lines.push('        ld b,TILE_WIDTH');
  lines.push('_sta_col_loop:');
  lines.push('        ld a,(hl)');
  lines.push('        ld (de),a');
  lines.push('        inc hl');
  lines.push('        inc e');
  lines.push('        djnz _sta_col_loop');
  lines.push('        pop de');
  lines.push('        pop bc');
  lines.push('        inc b');
  lines.push('        dec d');
  lines.push('        jr nz,_sta_row_loop');
  lines.push('        ret');
  lines.push('');

  const content = lines.join('\n');
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${fileName}_tile.asm`;
  a.click();
  URL.revokeObjectURL(url);

  return true;
}
