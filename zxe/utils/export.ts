import { Attribute, DrawBounds, TileSize, TileData, ScreenData, SoftwareSpriteFrame, SoftwareSpriteWidth, SoftwareSpriteHeight, SoftwareSpriteExportOptions } from '@/types';
import { CHAR_SIZE, MAX_UDG_CHARS, SCREEN_CHARS_WIDTH, SCREEN_CHARS_HEIGHT, TILE_SIZES } from '@/constants';

interface ExportParams {
  pixels: boolean[][];
  attributes: Attribute[][];
  bounds: DrawBounds;
  fileName: string;
}

// Export as ASM file (compact, game-ready format)
export function exportASM({ pixels, attributes, bounds, fileName }: ExportParams): boolean {
  const { minCharX, minCharY, width: exportWidth, height: exportHeight } = bounds;
  const totalChars = exportWidth * exportHeight;

  if (totalChars > MAX_UDG_CHARS) {
    alert(`Drawn content spans ${totalChars} characters, but ZX Spectrum only has ${MAX_UDG_CHARS} UDG slots. Please reduce the drawn area.`);
    return false;
  }

  const lines: string[] = [];

  // Header
  lines.push('; ZX Spectrum UDG Sprite Data');
  lines.push('; Generated by ZX Spectrum UDG Editor');
  lines.push(';');
  lines.push(`; Sprite dimensions: ${exportWidth}x${exportHeight} characters (${exportWidth * 8}x${exportHeight * 8} pixels)`);
  lines.push(`; Total characters: ${totalChars}`);
  lines.push(`; UDG data size: ${totalChars * 8} bytes`);
  lines.push(`; Attribute data size: ${totalChars} bytes`);
  lines.push('');

  // Constants
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Constants');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(`SPRITE_WIDTH    equ ${exportWidth}          ; Width in characters`);
  lines.push(`SPRITE_HEIGHT   equ ${exportHeight}          ; Height in characters`);
  lines.push(`SPRITE_CHARS    equ ${totalChars}         ; Total characters`);
  lines.push(`UDG_BYTES       equ ${totalChars * 8}        ; Bytes of UDG pixel data`);
  lines.push(`FIRST_UDG_CHAR  equ 144         ; First UDG character code`);
  lines.push('');

  // UDG pixel data - compact format (8 bytes per line = 1 character)
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; UDG Pixel Data (8 bytes per character, MSB=leftmost pixel)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('sprite_udg_data:');

  let charIndex = 0;
  for (let charY = minCharY; charY < minCharY + exportHeight; charY++) {
    for (let charX = minCharX; charX < minCharX + exportWidth; charX++) {
      const bytes: string[] = [];
      for (let row = 0; row < CHAR_SIZE; row++) {
        let byte = 0;
        for (let col = 0; col < CHAR_SIZE; col++) {
          const pixelX = charX * CHAR_SIZE + col;
          const pixelY = charY * CHAR_SIZE + row;
          if (pixels[pixelY][pixelX]) {
            byte |= 1 << (7 - col);
          }
        }
        bytes.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
      }
      lines.push(`        defb ${bytes.join(',')}  ; char ${charIndex} (row ${charY - minCharY}, col ${charX - minCharX})`);
      charIndex++;
    }
  }

  lines.push('');

  // Attribute data
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Attribute Data (1 byte per character)');
  lines.push('; Format: 0BPPPIII where B=bright, P=paper(0-7), I=ink(0-7)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('sprite_attr_data:');

  for (let charY = minCharY; charY < minCharY + exportHeight; charY++) {
    const rowAttrs: string[] = [];
    for (let charX = minCharX; charX < minCharX + exportWidth; charX++) {
      const attr = attributes[charY][charX];
      const byte = (attr.bright ? 0x40 : 0) | (attr.paper << 3) | attr.ink;
      rowAttrs.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
    }
    lines.push(`        defb ${rowAttrs.join(',')}  ; row ${charY - minCharY}`);
  }

  lines.push('');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Usage Example');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(';');
  lines.push('; To use this sprite in your game:');
  lines.push(';');
  lines.push('; 1. Include this file in your project');
  lines.push(';');
  lines.push('; 2. Set up UDGs at startup:');
  lines.push(';        ld hl,sprite_udg_data');
  lines.push(';        ld (23675),hl           ; Set UDG system variable');
  lines.push(';');
  lines.push('; 3. Print sprite at screen position (row,col):');
  lines.push(';        call print_sprite');
  lines.push(';');
  lines.push('; Or copy UDG data to a custom location:');
  lines.push(';        ld hl,sprite_udg_data');
  lines.push(';        ld de,your_udg_buffer');
  lines.push(';        ld bc,UDG_BYTES');
  lines.push(';        ldir');
  lines.push('');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Helper Routines (optional - remove if not needed)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('');
  lines.push('; Print sprite at position (B=row, C=col)');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('print_sprite:');
  lines.push('        ld d,SPRITE_HEIGHT');
  lines.push('        ld e,FIRST_UDG_CHAR');
  lines.push('_ps_row_loop:');
  lines.push('        push bc');
  lines.push('        push de');
  lines.push('        ; Position cursor (AT row,col)');
  lines.push('        ld a,22');
  lines.push('        rst 16');
  lines.push('        ld a,b');
  lines.push('        rst 16');
  lines.push('        ld a,c');
  lines.push('        rst 16');
  lines.push('        ; Print row of UDGs');
  lines.push('        ld b,SPRITE_WIDTH');
  lines.push('_ps_col_loop:');
  lines.push('        ld a,e');
  lines.push('        rst 16');
  lines.push('        inc e');
  lines.push('        djnz _ps_col_loop');
  lines.push('        pop de');
  lines.push('        pop bc');
  lines.push('        ; Move to next row');
  lines.push('        ld a,e');
  lines.push('        add a,SPRITE_WIDTH');
  lines.push('        ld e,a');
  lines.push('        inc b');
  lines.push('        dec d');
  lines.push('        jr nz,_ps_row_loop');
  lines.push('        ret');
  lines.push('');
  lines.push('; Set attributes for sprite at position (B=row, C=col)');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('set_sprite_attrs:');
  lines.push('        ld hl,sprite_attr_data');
  lines.push('        ld d,SPRITE_HEIGHT');
  lines.push('_sa_row_loop:');
  lines.push('        push bc');
  lines.push('        push de');
  lines.push('        ; Calculate attribute address: 22528 + row*32 + col');
  lines.push('        ld a,b');
  lines.push('        rrca');
  lines.push('        rrca');
  lines.push('        rrca');
  lines.push('        ld e,a');
  lines.push('        and $E0');
  lines.push('        ld d,a');
  lines.push('        ld a,e');
  lines.push('        and $03');
  lines.push('        or $58                  ; High byte of attr area');
  lines.push('        ld d,a');
  lines.push('        ld a,b');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        and $E0');
  lines.push('        or c');
  lines.push('        ld e,a');
  lines.push('        ; Copy attribute row');
  lines.push('        ld b,SPRITE_WIDTH');
  lines.push('_sa_col_loop:');
  lines.push('        ld a,(hl)');
  lines.push('        ld (de),a');
  lines.push('        inc hl');
  lines.push('        inc e');
  lines.push('        djnz _sa_col_loop');
  lines.push('        pop de');
  lines.push('        pop bc');
  lines.push('        inc b');
  lines.push('        dec d');
  lines.push('        jr nz,_sa_row_loop');
  lines.push('        ret');
  lines.push('');

  const content = lines.join('\n');
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${fileName}.asm`;
  a.click();
  URL.revokeObjectURL(url);

  return true;
}

// Screen export parameters
interface ScreenExportParams {
  pixels: boolean[][];
  attributes: Attribute[][];
  fileName: string;
}

// Export full ZX Spectrum screen as ASM file
// Screen memory layout: 6144 bytes display + 768 bytes attributes = 6912 bytes
// Display file at $4000, attributes at $5800
export function exportScreenASM({ pixels, attributes, fileName }: ScreenExportParams): boolean {
  const lines: string[] = [];

  // Header
  lines.push('; ZX Spectrum Full Screen Data');
  lines.push('; Generated by ZX Spectrum Scene Editor');
  lines.push(';');
  lines.push('; Screen dimensions: 256x192 pixels (32x24 characters)');
  lines.push('; Display data: 6144 bytes');
  lines.push('; Attribute data: 768 bytes');
  lines.push('; Total size: 6912 bytes');
  lines.push(';');
  lines.push('; Memory layout:');
  lines.push(';   Display file: $4000-$57FF (16384-22527)');
  lines.push(';   Attributes:   $5800-$5AFF (22528-23295)');
  lines.push('');

  // Constants
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Constants');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('SCREEN_START    equ $4000       ; Display file start');
  lines.push('ATTR_START      equ $5800       ; Attribute file start');
  lines.push('DISPLAY_SIZE    equ 6144        ; Display file size in bytes');
  lines.push('ATTR_SIZE       equ 768         ; Attribute file size in bytes');
  lines.push('SCREEN_SIZE     equ 6912        ; Total screen size in bytes');
  lines.push('');

  // Generate display file data in ZX Spectrum native format
  // The display file has a peculiar memory layout:
  // - 3 "thirds" of the screen (0-63, 64-127, 128-191 pixel rows)
  // - Each third: pixel lines are interleaved by character row
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Display File Data (6144 bytes)');
  lines.push('; Native ZX Spectrum screen format - can be copied directly to $4000');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('screen_display_data:');

  // Process each third of the screen
  for (let third = 0; third < 3; third++) {
    lines.push(`; --- Third ${third + 1} (pixel rows ${third * 64}-${third * 64 + 63}) ---`);

    // Each third has 8 pixel lines per character row, interleaved
    for (let pixelLine = 0; pixelLine < 8; pixelLine++) {
      for (let charRow = 0; charRow < 8; charRow++) {
        const screenRow = third * 64 + charRow * 8 + pixelLine;
        const rowBytes: string[] = [];

        for (let col = 0; col < SCREEN_CHARS_WIDTH; col++) {
          let byte = 0;
          for (let bit = 0; bit < 8; bit++) {
            const pixelX = col * 8 + bit;
            if (pixels[screenRow]?.[pixelX]) {
              byte |= 1 << (7 - bit);
            }
          }
          rowBytes.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        }

        // Split into two lines of 16 bytes each for readability
        lines.push(`        defb ${rowBytes.slice(0, 16).join(',')}`);
        lines.push(`        defb ${rowBytes.slice(16).join(',')}`);
      }
    }
  }

  lines.push('');

  // Generate attribute data (linear, one byte per character cell)
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Attribute Data (768 bytes)');
  lines.push('; Linear format - can be copied directly to $5800');
  lines.push('; Format: 0BPPPIII where B=bright, P=paper(0-7), I=ink(0-7)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('screen_attr_data:');

  for (let row = 0; row < SCREEN_CHARS_HEIGHT; row++) {
    const rowAttrs: string[] = [];
    for (let col = 0; col < SCREEN_CHARS_WIDTH; col++) {
      const attr = attributes[row]?.[col] || { ink: 7, paper: 0, bright: false };
      const byte = (attr.bright ? 0x40 : 0) | (attr.paper << 3) | attr.ink;
      rowAttrs.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
    }
    // Split into two lines of 16 bytes each for readability
    lines.push(`        defb ${rowAttrs.slice(0, 16).join(',')}  ; row ${row}`);
    lines.push(`        defb ${rowAttrs.slice(16).join(',')}`);
  }

  lines.push('');

  // Helper routines
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Helper Routines');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('');
  lines.push('; Load screen - copies display and attribute data to screen memory');
  lines.push('; Call this routine to display the screen');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('load_screen:');
  lines.push('        ; Copy display data to screen');
  lines.push('        ld hl,screen_display_data');
  lines.push('        ld de,SCREEN_START');
  lines.push('        ld bc,DISPLAY_SIZE');
  lines.push('        ldir');
  lines.push('        ; Copy attribute data');
  lines.push('        ld hl,screen_attr_data');
  lines.push('        ld de,ATTR_START');
  lines.push('        ld bc,ATTR_SIZE');
  lines.push('        ldir');
  lines.push('        ret');
  lines.push('');
  lines.push('; Clear screen to black');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('clear_screen:');
  lines.push('        ; Clear display file');
  lines.push('        ld hl,SCREEN_START');
  lines.push('        ld de,SCREEN_START+1');
  lines.push('        ld bc,DISPLAY_SIZE-1');
  lines.push('        ld (hl),0');
  lines.push('        ldir');
  lines.push('        ; Clear attributes (black on black)');
  lines.push('        ld hl,ATTR_START');
  lines.push('        ld de,ATTR_START+1');
  lines.push('        ld bc,ATTR_SIZE-1');
  lines.push('        ld (hl),0');
  lines.push('        ldir');
  lines.push('        ret');
  lines.push('');
  lines.push('; Set border colour (A = colour 0-7)');
  lines.push('; Modifies: AF');
  lines.push('set_border:');
  lines.push('        out ($FE),a');
  lines.push('        ret');
  lines.push('');

  // Usage example
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Usage Example');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(';');
  lines.push('; To display this screen in your program:');
  lines.push(';');
  lines.push(';   include "' + fileName + '.asm"');
  lines.push(';');
  lines.push(';   ; Display the loading screen');
  lines.push(';   call load_screen');
  lines.push(';');
  lines.push(';   ; Optionally set border colour');
  lines.push(';   ld a,0              ; Black border');
  lines.push(';   call set_border');
  lines.push(';');
  lines.push(';   ; Wait for keypress');
  lines.push(';   call wait_key');
  lines.push(';');
  lines.push('; For loading screens, you may want to load this data during tape loading');
  lines.push('; by placing it at the start of your program.');
  lines.push('');

  const content = lines.join('\n');
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${fileName}_screen.asm`;
  a.click();
  URL.revokeObjectURL(url);

  return true;
}

// Tile export parameters
interface TileExportParams {
  tileSize: TileSize;
  pixels: boolean[][];
  attributes: Attribute[][];
  fileName: string;
}

// Export tile as ASM file
export function exportTileASM({ tileSize, pixels, attributes, fileName }: TileExportParams): boolean {
  const config = TILE_SIZES[tileSize];
  const { chars: charDim, totalChars, label } = config;
  const lines: string[] = [];

  // Header
  lines.push('; ZX Spectrum Tile Data');
  lines.push('; Generated by ZX Spectrum Tile Editor');
  lines.push(';');
  lines.push(`; Tile dimensions: ${label} pixels (${charDim}x${charDim} characters)`);
  lines.push(`; Total characters: ${totalChars}`);
  lines.push(`; Pixel data size: ${totalChars * 8} bytes`);
  lines.push(`; Attribute data size: ${totalChars} bytes`);
  lines.push('');

  // Constants
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Constants');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(`TILE_WIDTH      equ ${charDim}           ; Width in characters`);
  lines.push(`TILE_HEIGHT     equ ${charDim}           ; Height in characters`);
  lines.push(`TILE_CHARS      equ ${totalChars}           ; Total characters`);
  lines.push(`TILE_BYTES      equ ${totalChars * 8}          ; Bytes of pixel data`);
  lines.push(`FIRST_UDG_CHAR  equ 144         ; First UDG character code`);
  lines.push('');

  // Pixel data - compact format (8 bytes per line = 1 character)
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Tile Pixel Data (8 bytes per character, MSB=leftmost pixel)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('tile_data:');

  let charIndex = 0;
  for (let charY = 0; charY < charDim; charY++) {
    for (let charX = 0; charX < charDim; charX++) {
      const bytes: string[] = [];
      for (let row = 0; row < CHAR_SIZE; row++) {
        let byte = 0;
        for (let col = 0; col < CHAR_SIZE; col++) {
          const pixelX = charX * CHAR_SIZE + col;
          const pixelY = charY * CHAR_SIZE + row;
          if (pixels[pixelY]?.[pixelX]) {
            byte |= 1 << (7 - col);
          }
        }
        bytes.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
      }
      if (totalChars > 1) {
        lines.push(`        defb ${bytes.join(',')}  ; char ${charIndex} (row ${charY}, col ${charX})`);
      } else {
        lines.push(`        defb ${bytes.join(',')}`);
      }
      charIndex++;
    }
  }

  lines.push('');

  // Attribute data
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Tile Attribute Data (1 byte per character)');
  lines.push('; Format: 0BPPPIII where B=bright, P=paper(0-7), I=ink(0-7)');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('tile_attr_data:');

  for (let charY = 0; charY < charDim; charY++) {
    const rowAttrs: string[] = [];
    for (let charX = 0; charX < charDim; charX++) {
      const attr = attributes[charY]?.[charX] || { ink: 7, paper: 0, bright: true };
      const byte = (attr.bright ? 0x40 : 0) | (attr.paper << 3) | attr.ink;
      rowAttrs.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
    }
    if (charDim > 1) {
      lines.push(`        defb ${rowAttrs.join(',')}  ; row ${charY}`);
    } else {
      lines.push(`        defb ${rowAttrs.join(',')}`);
    }
  }

  lines.push('');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Usage Example');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(';');
  lines.push('; To use this tile in your game:');
  lines.push(';');
  lines.push(`;   include "${fileName}_tile.asm"`);
  lines.push(';');
  lines.push('; 1. Set up UDGs at startup:');
  lines.push(';        ld hl,tile_data');
  lines.push(';        ld (23675),hl           ; Set UDG system variable');
  lines.push(';');
  lines.push('; 2. Print tile at screen position (B=row, C=col):');
  lines.push(';        ld b,10                 ; Row');
  lines.push(';        ld c,15                 ; Column');
  lines.push(';        call print_tile');
  lines.push(';        call set_tile_attrs');
  lines.push('');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Helper Routines');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('');
  lines.push('; Print tile at position (B=row, C=col)');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('print_tile:');
  lines.push('        push bc');
  lines.push('        ; Set UDG pointer');
  lines.push('        ld hl,tile_data');
  lines.push('        ld (23675),hl');
  lines.push('        pop bc');
  lines.push('        ld d,TILE_HEIGHT');
  lines.push('        ld e,FIRST_UDG_CHAR');
  lines.push('_pt_row_loop:');
  lines.push('        push bc');
  lines.push('        push de');
  lines.push('        ; Position cursor (AT row,col)');
  lines.push('        ld a,22');
  lines.push('        rst 16');
  lines.push('        ld a,b');
  lines.push('        rst 16');
  lines.push('        ld a,c');
  lines.push('        rst 16');
  lines.push('        ; Print row of tile characters');
  lines.push('        ld b,TILE_WIDTH');
  lines.push('_pt_col_loop:');
  lines.push('        ld a,e');
  lines.push('        rst 16');
  lines.push('        inc e');
  lines.push('        djnz _pt_col_loop');
  lines.push('        pop de');
  lines.push('        pop bc');
  lines.push('        ; Move to next row');
  lines.push('        ld a,e');
  lines.push('        add a,TILE_WIDTH');
  lines.push('        ld e,a');
  lines.push('        inc b');
  lines.push('        dec d');
  lines.push('        jr nz,_pt_row_loop');
  lines.push('        ret');
  lines.push('');
  lines.push('; Set attributes for tile at position (B=row, C=col)');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('set_tile_attrs:');
  lines.push('        ld hl,tile_attr_data');
  lines.push('        ld d,TILE_HEIGHT');
  lines.push('_sta_row_loop:');
  lines.push('        push bc');
  lines.push('        push de');
  lines.push('        ; Calculate attribute address: 22528 + row*32 + col');
  lines.push('        ld a,b');
  lines.push('        rrca');
  lines.push('        rrca');
  lines.push('        rrca');
  lines.push('        ld e,a');
  lines.push('        and $E0');
  lines.push('        ld d,a');
  lines.push('        ld a,e');
  lines.push('        and $03');
  lines.push('        or $58                  ; High byte of attr area');
  lines.push('        ld d,a');
  lines.push('        ld a,b');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        rlca');
  lines.push('        and $E0');
  lines.push('        or c');
  lines.push('        ld e,a');
  lines.push('        ; Copy attribute row');
  lines.push('        ld b,TILE_WIDTH');
  lines.push('_sta_col_loop:');
  lines.push('        ld a,(hl)');
  lines.push('        ld (de),a');
  lines.push('        inc hl');
  lines.push('        inc e');
  lines.push('        djnz _sta_col_loop');
  lines.push('        pop de');
  lines.push('        pop bc');
  lines.push('        inc b');
  lines.push('        dec d');
  lines.push('        jr nz,_sta_row_loop');
  lines.push('        ret');
  lines.push('');

  const content = lines.join('\n');
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${fileName}_tile.asm`;
  a.click();
  URL.revokeObjectURL(url);

  return true;
}

// Level export parameters
interface LevelExportParams {
  tileSize: TileSize;
  tileLibrary: TileData[];
  screens: ScreenData[];
  fileName: string;
}

// Export level as ASM file with tile definitions and screen maps
export function exportLevelASM({ tileSize, tileLibrary, screens, fileName }: LevelExportParams): boolean {
  const config = TILE_SIZES[tileSize];
  const { chars: charDim, totalChars, label } = config;
  const lines: string[] = [];

  // Calculate grid dimensions
  const gridCols = tileSize === 8 ? 32 : tileSize === 16 ? 16 : 10;
  const gridRows = tileSize === 8 ? 24 : tileSize === 16 ? 12 : 8;

  // Header
  lines.push('; ZX Spectrum Level Data');
  lines.push('; Generated by ZX Spectrum Level Editor');
  lines.push(';');
  lines.push(`; Level: ${fileName}`);
  lines.push(`; Tile size: ${label} pixels (${charDim}x${charDim} characters)`);
  lines.push(`; Grid: ${gridCols}x${gridRows} tiles per screen`);
  lines.push(`; Tile library: ${tileLibrary.length} tiles`);
  lines.push(`; Screens: ${screens.length}`);
  lines.push('');

  // Constants
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Constants');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(`TILE_SIZE       equ ${tileSize}          ; Tile size in pixels`);
  lines.push(`TILE_CHARS      equ ${charDim}           ; Characters per tile dimension`);
  lines.push(`TOTAL_CHARS     equ ${totalChars}          ; Characters per tile`);
  lines.push(`GRID_WIDTH      equ ${gridCols}          ; Tiles per row`);
  lines.push(`GRID_HEIGHT     equ ${gridRows}          ; Tiles per column`);
  lines.push(`TILE_COUNT      equ ${tileLibrary.length}           ; Number of tiles in library`);
  lines.push(`SCREEN_COUNT    equ ${screens.length}           ; Number of screens`);
  lines.push(`TILE_BYTES      equ ${totalChars * 8}          ; Pixel bytes per tile`);
  lines.push(`FIRST_UDG_CHAR  equ 144         ; First UDG character code`);
  lines.push(`EMPTY_TILE      equ 255         ; Empty tile marker`);
  lines.push('');

  // Tile pixel data
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Tile Pixel Data');
  lines.push('; Each tile: ' + totalChars * 8 + ' bytes (8 bytes per character)');
  lines.push('; -----------------------------------------------------------------------------');

  tileLibrary.forEach((tile, tileIndex) => {
    lines.push(`tile_${tileIndex}_data:  ; "${tile.name}"`);

    for (let charY = 0; charY < charDim; charY++) {
      for (let charX = 0; charX < charDim; charX++) {
        const bytes: string[] = [];
        for (let row = 0; row < CHAR_SIZE; row++) {
          let byte = 0;
          for (let col = 0; col < CHAR_SIZE; col++) {
            const pixelX = charX * CHAR_SIZE + col;
            const pixelY = charY * CHAR_SIZE + row;
            if (tile.pixels[pixelY]?.[pixelX]) {
              byte |= 1 << (7 - col);
            }
          }
          bytes.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
        }
        if (totalChars > 1) {
          lines.push(`        defb ${bytes.join(',')}  ; char (${charY},${charX})`);
        } else {
          lines.push(`        defb ${bytes.join(',')}`);
        }
      }
    }
    lines.push('');
  });

  // Tile attribute data
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Tile Attribute Data');
  lines.push('; Each tile: ' + totalChars + ' byte(s)');
  lines.push('; Format: 0BPPPIII where B=bright, P=paper(0-7), I=ink(0-7)');
  lines.push('; -----------------------------------------------------------------------------');

  tileLibrary.forEach((tile, tileIndex) => {
    const attrBytes: string[] = [];
    for (let charY = 0; charY < charDim; charY++) {
      for (let charX = 0; charX < charDim; charX++) {
        const attr = tile.attributes[charY]?.[charX] || { ink: 7, paper: 0, bright: true };
        const byte = (attr.bright ? 0x40 : 0) | (attr.paper << 3) | attr.ink;
        attrBytes.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
      }
    }
    lines.push(`tile_${tileIndex}_attr:  defb ${attrBytes.join(',')}  ; "${tile.name}"`);
  });

  lines.push('');

  // Tile lookup tables
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Tile Lookup Tables');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('tile_data_table:');
  tileLibrary.forEach((_, tileIndex) => {
    lines.push(`        defw tile_${tileIndex}_data`);
  });
  lines.push('');
  lines.push('tile_attr_table:');
  tileLibrary.forEach((_, tileIndex) => {
    lines.push(`        defw tile_${tileIndex}_attr`);
  });
  lines.push('');

  // Screen maps
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Screen Maps');
  lines.push(`; Each screen: ${gridCols * gridRows} bytes (${gridCols}x${gridRows} tile indices)`);
  lines.push('; 255 ($FF) = empty tile');
  lines.push('; -----------------------------------------------------------------------------');

  screens.forEach((screen, screenIndex) => {
    lines.push(`screen_${screenIndex}_map:  ; "${screen.name}"`);
    for (let row = 0; row < gridRows; row++) {
      const rowBytes: string[] = [];
      for (let col = 0; col < gridCols; col++) {
        const tileIndex = screen.map[row]?.[col];
        const value = tileIndex === null || tileIndex === undefined ? 255 : tileIndex;
        rowBytes.push(`$${value.toString(16).padStart(2, '0').toUpperCase()}`);
      }
      lines.push(`        defb ${rowBytes.join(',')}  ; row ${row}`);
    }
    lines.push('');
  });

  // Screen lookup table
  lines.push('; Screen lookup table');
  lines.push('screen_table:');
  screens.forEach((_, screenIndex) => {
    lines.push(`        defw screen_${screenIndex}_map`);
  });
  lines.push('');

  // Helper routines
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Helper Routines');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('');
  lines.push('; Draw a single tile at position (B=row, C=col, A=tile index)');
  lines.push('; Uses UDG system to print tile characters with correct colors');
  lines.push('; Note: Does not use IY as RST 16 requires IY to point to system vars');
  lines.push('; Modifies: AF, BC, DE, HL');
  lines.push('draw_tile:');
  lines.push('        cp EMPTY_TILE');
  lines.push('        ret z                   ; Skip empty tiles');
  lines.push('        ; Save screen position');
  lines.push('        ld (_dt_row_pos),bc');
  lines.push('        ; Calculate tile data address');
  lines.push('        ld l,a');
  lines.push('        ld h,0');
  lines.push('        add hl,hl               ; x2 for word table');
  lines.push('        ld (_dt_tbl_off),hl     ; Save table offset');
  lines.push('        ld de,tile_data_table');
  lines.push('        add hl,de');
  lines.push('        ld e,(hl)');
  lines.push('        inc hl');
  lines.push('        ld d,(hl)               ; DE = tile data address');
  lines.push('        ; Set UDG pointer');
  lines.push('        ld (23675),de');
  lines.push('        ; Calculate tile attribute address');
  lines.push('        ld hl,(_dt_tbl_off)     ; Restore table offset');
  lines.push('        ld de,tile_attr_table');
  lines.push('        add hl,de');
  lines.push('        ld e,(hl)');
  lines.push('        inc hl');
  lines.push('        ld d,(hl)');
  lines.push('        ld (_dt_attr_ptr),de    ; Store attribute pointer');
  lines.push('        ; Initialize loop counters');
  lines.push('        ld a,TILE_CHARS');
  lines.push('        ld (_dt_row_cnt),a');
  lines.push('        ld a,FIRST_UDG_CHAR');
  lines.push('        ld (_dt_udg_char),a');
  lines.push('_dt_row_loop:');
  lines.push('        ; Position cursor (AT row,col)');
  lines.push('        ld a,22');
  lines.push('        rst 16');
  lines.push('        ld bc,(_dt_row_pos)');
  lines.push('        ld a,b');
  lines.push('        rst 16');
  lines.push('        ld a,c');
  lines.push('        rst 16');
  lines.push('        ; Print row of chars with attributes');
  lines.push('        ld a,TILE_CHARS');
  lines.push('        ld (_dt_col_cnt),a');
  lines.push('_dt_col_loop:');
  lines.push('        ; Get attribute byte from pointer');
  lines.push('        ld hl,(_dt_attr_ptr)');
  lines.push('        ld a,(hl)');
  lines.push('        inc hl');
  lines.push('        ld (_dt_attr_ptr),hl    ; Update pointer');
  lines.push('        ld (_dt_attr_val),a     ; Save attribute value');
  lines.push('        ; Set INK (bits 0-2)');
  lines.push('        ld a,16                 ; INK control code');
  lines.push('        rst 16');
  lines.push('        ld a,(_dt_attr_val)');
  lines.push('        and $07                 ; Mask ink bits');
  lines.push('        rst 16');
  lines.push('        ; Set PAPER (bits 3-5)');
  lines.push('        ld a,17                 ; PAPER control code');
  lines.push('        rst 16');
  lines.push('        ld a,(_dt_attr_val)');
  lines.push('        rrca');
  lines.push('        rrca');
  lines.push('        rrca                    ; Bits 3-5 now in bits 0-2');
  lines.push('        and $07                 ; Mask paper bits');
  lines.push('        rst 16');
  lines.push('        ; Set BRIGHT (bit 6)');
  lines.push('        ld a,19                 ; BRIGHT control code');
  lines.push('        rst 16');
  lines.push('        ld a,(_dt_attr_val)');
  lines.push('        rlca');
  lines.push('        rlca                    ; Bit 6 now in bit 0');
  lines.push('        and $01                 ; Mask bright bit');
  lines.push('        rst 16');
  lines.push('        ; Print the UDG character');
  lines.push('        ld a,(_dt_udg_char)');
  lines.push('        rst 16');
  lines.push('        inc a');
  lines.push('        ld (_dt_udg_char),a');
  lines.push('        ; Next column');
  lines.push('        ld a,(_dt_col_cnt)');
  lines.push('        dec a');
  lines.push('        ld (_dt_col_cnt),a');
  lines.push('        jr nz,_dt_col_loop');
  lines.push('        ; Move to next row');
  lines.push('        ld bc,(_dt_row_pos)');
  lines.push('        inc b                   ; Next screen row');
  lines.push('        ld (_dt_row_pos),bc');
  lines.push('        ld a,(_dt_row_cnt)');
  lines.push('        dec a');
  lines.push('        ld (_dt_row_cnt),a');
  lines.push('        jr nz,_dt_row_loop');
  lines.push('        ret');
  lines.push('');
  lines.push('; Working variables for draw_tile');
  lines.push('_dt_row_pos:  defw 0              ; Current row,col position');
  lines.push('_dt_tbl_off:  defw 0              ; Table offset');
  lines.push('_dt_attr_ptr: defw 0              ; Attribute data pointer');
  lines.push('_dt_attr_val: defb 0              ; Current attribute value');
  lines.push('_dt_row_cnt:  defb 0              ; Row counter');
  lines.push('_dt_col_cnt:  defb 0              ; Column counter');
  lines.push('_dt_udg_char: defb 0              ; Current UDG character');
  lines.push('');
  lines.push('; Draw entire screen (IX = screen map address)');
  lines.push('; Modifies: All registers');
  lines.push('draw_screen:');
  lines.push('        ld c,0                  ; Start column (in characters)');
  lines.push('        ld b,0                  ; Start row (in characters)');
  lines.push('        ld d,GRID_HEIGHT');
  lines.push('_ds_row:');
  lines.push('        push de');
  lines.push('        ld e,GRID_WIDTH');
  lines.push('_ds_col:');
  lines.push('        push bc');
  lines.push('        push de');
  lines.push('        ld a,(ix+0)');
  lines.push('        inc ix');
  lines.push('        call draw_tile');
  lines.push('        pop de');
  lines.push('        pop bc');
  lines.push('        ld a,c');
  lines.push('        add a,TILE_CHARS');
  lines.push('        ld c,a                  ; Next column');
  lines.push('        dec e');
  lines.push('        jr nz,_ds_col');
  lines.push('        ld c,0                  ; Reset column');
  lines.push('        ld a,b');
  lines.push('        add a,TILE_CHARS');
  lines.push('        ld b,a                  ; Next row');
  lines.push('        pop de');
  lines.push('        dec d');
  lines.push('        jr nz,_ds_row');
  lines.push('        ret');
  lines.push('');
  lines.push('; Load and draw screen N (A = screen index)');
  lines.push('; Modifies: All registers');
  lines.push('load_screen:');
  lines.push('        ld l,a');
  lines.push('        ld h,0');
  lines.push('        add hl,hl               ; x2 for word table');
  lines.push('        ld de,screen_table');
  lines.push('        add hl,de');
  lines.push('        ld e,(hl)');
  lines.push('        inc hl');
  lines.push('        ld d,(hl)');
  lines.push('        push de');
  lines.push('        pop ix                  ; IX = screen map');
  lines.push('        jp draw_screen');
  lines.push('');

  // Usage example
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Usage Example');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(';');
  lines.push(';   include "' + fileName + '_level.asm"');
  lines.push(';');
  lines.push(';   ; Load and display screen 0');
  lines.push(';   xor a                       ; Screen 0');
  lines.push(';   call load_screen');
  lines.push(';');
  lines.push(';   ; Or manually set up and draw a screen');
  lines.push(';   ld ix,screen_0_map');
  lines.push(';   call draw_screen');
  lines.push(';');
  lines.push(';   ; Draw individual tile at position');
  lines.push(';   ld b,5                      ; Row (in characters)');
  lines.push(';   ld c,10                     ; Column (in characters)');
  lines.push(';   ld a,0                      ; Tile index');
  lines.push(';   call draw_tile');
  lines.push('');

  const content = lines.join('\n');
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${fileName}_level.asm`;
  a.click();
  URL.revokeObjectURL(url);

  return true;
}

// Software Sprite export parameters
interface SoftwareSpriteExportParams {
  spriteWidth: SoftwareSpriteWidth;
  spriteHeight: SoftwareSpriteHeight;
  frames: SoftwareSpriteFrame[];
  fileName: string;
  options: SoftwareSpriteExportOptions;
}

// Generate pre-shifted sprite data
// For horizontal scrolling, we generate 8 variants (shift 0-7 pixels right)
// Each shift adds one overflow byte per row
function generatePreShiftedData(
  pixels: boolean[][],
  widthBytes: number
): { spriteData: number[][][]; maskData: number[][][] } {
  const height = pixels.length;
  const spriteData: number[][][] = []; // [shift][row][bytes]
  const maskData: number[][][] = [];   // [shift][row][bytes]

  for (let shift = 0; shift < 8; shift++) {
    const shiftedSprite: number[][] = [];
    const shiftedMask: number[][] = [];

    for (let row = 0; row < height; row++) {
      const rowPixels = pixels[row] || [];
      const shiftedWidth = widthBytes + 1; // One extra byte for overflow
      const spriteBytes: number[] = Array(shiftedWidth).fill(0);
      const maskBytes: number[] = Array(shiftedWidth).fill(0xFF);

      // Shift each byte by 'shift' pixels
      for (let byteIndex = 0; byteIndex < widthBytes; byteIndex++) {
        let originalByte = 0;
        let originalMask = 0xFF;

        // Build original byte from pixels
        for (let bit = 0; bit < 8; bit++) {
          const pixelX = byteIndex * 8 + bit;
          if (pixelX < rowPixels.length && rowPixels[pixelX]) {
            originalByte |= 1 << (7 - bit);
            originalMask &= ~(1 << (7 - bit));
          }
        }

        // Shift right by 'shift' positions
        spriteBytes[byteIndex] |= (originalByte >> shift);
        spriteBytes[byteIndex + 1] |= (originalByte << (8 - shift)) & 0xFF;

        // Shift mask
        maskBytes[byteIndex] &= (originalMask >> shift) | (0xFF << (8 - shift));
        maskBytes[byteIndex + 1] &= ((originalMask << (8 - shift)) & 0xFF) | (0xFF >> shift);
      }

      shiftedSprite.push(spriteBytes);
      shiftedMask.push(maskBytes);
    }

    spriteData.push(shiftedSprite);
    maskData.push(shiftedMask);
  }

  return { spriteData, maskData };
}

// Export software sprite as ASM file with pre-shifting and masking
export function exportSoftwareSpriteASM({
  spriteWidth,
  spriteHeight,
  frames,
  fileName,
  options,
}: SoftwareSpriteExportParams): boolean {
  const widthBytes = spriteWidth / 8;
  const shiftedWidthBytes = widthBytes + 1;
  const lines: string[] = [];

  // Header
  lines.push('; ZX Spectrum Software Sprite Data');
  lines.push('; Generated by ZX Spectrum Software Sprite Editor');
  lines.push(';');
  lines.push(`; Sprite dimensions: ${spriteWidth}x${spriteHeight} pixels`);
  lines.push(`; Width in bytes: ${widthBytes} (${shiftedWidthBytes} when pre-shifted)`);
  lines.push(`; Frame count: ${frames.length}`);
  if (options.includePreShifts) {
    lines.push('; Pre-shift variants: 8 (for smooth horizontal scrolling)');
  }
  if (options.includeMask) {
    lines.push(`; Mask interleaving: ${options.interleaving}`);
  }
  lines.push(';');
  lines.push('; Drawing technique: screen = (screen AND mask) OR sprite');
  lines.push('');

  // Constants
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Constants');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(`SPRITE_WIDTH_PIXELS equ ${spriteWidth}`);
  lines.push(`SPRITE_HEIGHT       equ ${spriteHeight}`);
  lines.push(`SPRITE_WIDTH_BYTES  equ ${widthBytes}`);
  if (options.includePreShifts) {
    lines.push(`SHIFTED_WIDTH_BYTES equ ${shiftedWidthBytes}`);
    lines.push('PRESHIFT_COUNT      equ 8');
  }
  lines.push(`FRAME_COUNT         equ ${frames.length}`);
  lines.push('');

  // Frame lookup table
  if (options.generateLookupTable && frames.length > 1) {
    lines.push('; -----------------------------------------------------------------------------');
    lines.push('; Frame Lookup Table');
    lines.push('; -----------------------------------------------------------------------------');
    lines.push('frame_table:');
    frames.forEach((frame, i) => {
      lines.push(`        defw frame_${i}  ; "${frame.name}"`);
    });
    lines.push('');
  }

  // Generate data for each frame
  frames.forEach((frame, frameIndex) => {
    lines.push('; -----------------------------------------------------------------------------');
    lines.push(`; Frame ${frameIndex}: "${frame.name}"`);
    lines.push('; -----------------------------------------------------------------------------');

    if (options.includePreShifts) {
      // Pre-shifted data with or without masks
      const { spriteData, maskData } = generatePreShiftedData(
        frame.pixels,
        widthBytes
      );

      // Shift lookup table for this frame
      lines.push(`frame_${frameIndex}:`);
      for (let shift = 0; shift < 8; shift++) {
        lines.push(`        defw frame_${frameIndex}_shift_${shift}`);
      }
      lines.push('');

      // Each shift variant
      for (let shift = 0; shift < 8; shift++) {
        lines.push(`frame_${frameIndex}_shift_${shift}:`);

        if (options.includeMask && options.interleaving === 'sprite-mask') {
          // Interleaved: sprite bytes then mask bytes per row
          for (let row = 0; row < spriteHeight; row++) {
            const spriteBytesStr = spriteData[shift][row]
              .map((b) => `$${b.toString(16).padStart(2, '0').toUpperCase()}`)
              .join(',');
            const maskBytesStr = maskData[shift][row]
              .map((b) => `$${b.toString(16).padStart(2, '0').toUpperCase()}`)
              .join(',');
            lines.push(`        defb ${spriteBytesStr}, ${maskBytesStr}  ; row ${row}`);
          }
        } else {
          // Sprite data only or separate blocks
          for (let row = 0; row < spriteHeight; row++) {
            const spriteBytesStr = spriteData[shift][row]
              .map((b) => `$${b.toString(16).padStart(2, '0').toUpperCase()}`)
              .join(',');
            lines.push(`        defb ${spriteBytesStr}  ; row ${row}`);
          }

          if (options.includeMask && options.interleaving === 'separate-blocks') {
            lines.push(`frame_${frameIndex}_shift_${shift}_mask:`);
            for (let row = 0; row < spriteHeight; row++) {
              const maskBytesStr = maskData[shift][row]
                .map((b) => `$${b.toString(16).padStart(2, '0').toUpperCase()}`)
                .join(',');
              lines.push(`        defb ${maskBytesStr}  ; row ${row}`);
            }
          }
        }
        lines.push('');
      }
    } else {
      // Non-pre-shifted (simple) export
      lines.push(`frame_${frameIndex}:`);

      if (options.includeMask && options.interleaving === 'sprite-mask') {
        // Interleaved sprite and mask per row
        for (let row = 0; row < spriteHeight; row++) {
          const rowPixels = frame.pixels[row] || [];
          const spriteBytesArr: string[] = [];
          const maskBytesArr: string[] = [];

          for (let byteIndex = 0; byteIndex < widthBytes; byteIndex++) {
            let spriteByte = 0;
            let maskByte = 0xFF;

            for (let bit = 0; bit < 8; bit++) {
              const pixelX = byteIndex * 8 + bit;
              if (pixelX < rowPixels.length && rowPixels[pixelX]) {
                spriteByte |= 1 << (7 - bit);
                maskByte &= ~(1 << (7 - bit));
              }
            }

            spriteBytesArr.push(`$${spriteByte.toString(16).padStart(2, '0').toUpperCase()}`);
            maskBytesArr.push(`$${maskByte.toString(16).padStart(2, '0').toUpperCase()}`);
          }

          lines.push(`        defb ${spriteBytesArr.join(',')}, ${maskBytesArr.join(',')}  ; row ${row}`);
        }
      } else {
        // Sprite data only
        for (let row = 0; row < spriteHeight; row++) {
          const rowPixels = frame.pixels[row] || [];
          const spriteBytesArr: string[] = [];

          for (let byteIndex = 0; byteIndex < widthBytes; byteIndex++) {
            let spriteByte = 0;

            for (let bit = 0; bit < 8; bit++) {
              const pixelX = byteIndex * 8 + bit;
              if (pixelX < rowPixels.length && rowPixels[pixelX]) {
                spriteByte |= 1 << (7 - bit);
              }
            }

            spriteBytesArr.push(`$${spriteByte.toString(16).padStart(2, '0').toUpperCase()}`);
          }

          lines.push(`        defb ${spriteBytesArr.join(',')}  ; row ${row}`);
        }

        if (options.includeMask && options.interleaving === 'separate-blocks') {
          lines.push(`frame_${frameIndex}_mask:`);
          for (let row = 0; row < spriteHeight; row++) {
            const rowPixels = frame.pixels[row] || [];
            const maskBytesArr: string[] = [];

            for (let byteIndex = 0; byteIndex < widthBytes; byteIndex++) {
              let maskByte = 0xFF;

              for (let bit = 0; bit < 8; bit++) {
                const pixelX = byteIndex * 8 + bit;
                if (pixelX < rowPixels.length && rowPixels[pixelX]) {
                  maskByte &= ~(1 << (7 - bit));
                }
              }

              maskBytesArr.push(`$${maskByte.toString(16).padStart(2, '0').toUpperCase()}`);
            }

            lines.push(`        defb ${maskBytesArr.join(',')}  ; row ${row}`);
          }
        }
      }
      lines.push('');
    }

    // Attribute data for frame
    const widthChars = spriteWidth / 8;
    const heightChars = spriteHeight / 8;
    lines.push(`frame_${frameIndex}_attr:`);
    for (let charY = 0; charY < heightChars; charY++) {
      const rowAttrs: string[] = [];
      for (let charX = 0; charX < widthChars; charX++) {
        const attr = frame.attributes[charY]?.[charX] || { ink: 7, paper: 0, bright: true };
        const byte = (attr.bright ? 0x40 : 0) | (attr.paper << 3) | attr.ink;
        rowAttrs.push(`$${byte.toString(16).padStart(2, '0').toUpperCase()}`);
      }
      lines.push(`        defb ${rowAttrs.join(',')}  ; row ${charY}`);
    }
    lines.push('');
  });

  // Helper routines
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Helper Routines');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('');
  lines.push('; Draw sprite at screen address (HL = screen address, IX = sprite data)');
  lines.push('; Uses: AF, BC, DE, HL, IX');

  if (options.includeMask) {
    lines.push('; This version uses masking for transparent pixels');
    lines.push('draw_sprite_masked:');
    lines.push('        ld b,SPRITE_HEIGHT');
    lines.push('_dsm_row:');
    lines.push('        push hl');
    if (options.includePreShifts) {
      lines.push(`        ld c,SHIFTED_WIDTH_BYTES`);
    } else {
      lines.push(`        ld c,SPRITE_WIDTH_BYTES`);
    }
    lines.push('_dsm_col:');
    if (options.interleaving === 'sprite-mask') {
      lines.push('        ld a,(ix+0)         ; Get sprite byte');
      lines.push('        ld d,a              ; Save sprite');
      if (options.includePreShifts) {
        lines.push(`        ld a,(ix+SHIFTED_WIDTH_BYTES) ; Get mask byte`);
      } else {
        lines.push(`        ld a,(ix+SPRITE_WIDTH_BYTES) ; Get mask byte`);
      }
    } else {
      lines.push('        ld a,(ix+0)         ; Get sprite byte');
      lines.push('        ld d,a              ; Save sprite');
      lines.push('        ; Mask would be at separate address');
    }
    lines.push('        and (hl)            ; Apply mask to screen');
    lines.push('        or d                ; OR in sprite');
    lines.push('        ld (hl),a           ; Store result');
    lines.push('        inc hl');
    lines.push('        inc ix');
    lines.push('        dec c');
    lines.push('        jr nz,_dsm_col');
    if (options.interleaving === 'sprite-mask') {
      if (options.includePreShifts) {
        lines.push(`        ld de,SHIFTED_WIDTH_BYTES`);
      } else {
        lines.push(`        ld de,SPRITE_WIDTH_BYTES`);
      }
      lines.push('        add ix,de           ; Skip mask bytes');
    }
    lines.push('        pop hl');
    lines.push('        call next_screen_line');
    lines.push('        djnz _dsm_row');
    lines.push('        ret');
  } else {
    lines.push('; This version overwrites screen (no masking)');
    lines.push('draw_sprite:');
    lines.push('        ld b,SPRITE_HEIGHT');
    lines.push('_ds_row:');
    lines.push('        push hl');
    if (options.includePreShifts) {
      lines.push(`        ld c,SHIFTED_WIDTH_BYTES`);
    } else {
      lines.push(`        ld c,SPRITE_WIDTH_BYTES`);
    }
    lines.push('_ds_col:');
    lines.push('        ld a,(ix+0)');
    lines.push('        ld (hl),a');
    lines.push('        inc hl');
    lines.push('        inc ix');
    lines.push('        dec c');
    lines.push('        jr nz,_ds_col');
    lines.push('        pop hl');
    lines.push('        call next_screen_line');
    lines.push('        djnz _ds_row');
    lines.push('        ret');
  }

  lines.push('');
  lines.push('; Move to next screen line (HL = current address)');
  lines.push('; Handles ZX Spectrum screen memory layout');
  lines.push('next_screen_line:');
  lines.push('        inc h');
  lines.push('        ld a,h');
  lines.push('        and $07');
  lines.push('        ret nz');
  lines.push('        ld a,l');
  lines.push('        add a,32');
  lines.push('        ld l,a');
  lines.push('        ret c');
  lines.push('        ld a,h');
  lines.push('        sub 8');
  lines.push('        ld h,a');
  lines.push('        ret');
  lines.push('');

  // Usage example
  lines.push('; -----------------------------------------------------------------------------');
  lines.push('; Usage Example');
  lines.push('; -----------------------------------------------------------------------------');
  lines.push(';');
  lines.push(`;   include "${fileName}_sprite.asm"`);
  lines.push(';');
  if (options.includePreShifts) {
    lines.push(';   ; Get pre-shifted variant (A = x position AND 7)');
    lines.push(';   ld a,(sprite_x)');
    lines.push(';   and 7');
    lines.push(';   add a,a             ; x2 for word table');
    lines.push(';   ld hl,frame_0');
    lines.push(';   ld e,a');
    lines.push(';   ld d,0');
    lines.push(';   add hl,de');
    lines.push(';   ld e,(hl)');
    lines.push(';   inc hl');
    lines.push(';   ld d,(hl)           ; DE = address of shifted sprite');
    lines.push(';   push de');
    lines.push(';   pop ix              ; IX = sprite data');
  } else {
    lines.push(';   ld ix,frame_0       ; Point to sprite data');
  }
  lines.push(';');
  lines.push(';   ; Calculate screen address');
  lines.push(';   ld a,(sprite_y)');
  lines.push(';   call get_screen_addr  ; Returns HL = screen address');
  lines.push(';');
  if (options.includeMask) {
    lines.push(';   call draw_sprite_masked');
  } else {
    lines.push(';   call draw_sprite');
  }
  lines.push('');

  const content = lines.join('\n');
  const blob = new Blob([content], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${fileName}_sprite.asm`;
  a.click();
  URL.revokeObjectURL(url);

  return true;
}
